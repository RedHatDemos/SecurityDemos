= Cloud encryption using RHEL Opportunistic IPsec

== Goal of Lab:
In this lab exercise, you will learn how to deploy Opportunistic IPsec to encrypt
all host to host communication within an enterprise network. Whenever two
hosts in the network want to send any kind of traffic, IPsec security will
automatically activate and encrypt all traffic between those hosts. This
is also called mesh encryption.

In this lab exercise, you will learn:

* How to generate X.509 certificates using a python helper script
* Configure Opportunistic IPsec on two or more nodes
* How to debug and monitor the network for IPsec encryption

== Introduction:

Imagine a LAN of various machines. Each machine is given an X.509
certificate in the form of a PKCS#12 file (eg ipsecXXX.example.com). This
file contains the Certificate Agency of Example Org and the node's own
certificate and private key.  Machines in the network should automatically
initiate IPsec encryption and authenticate each other based on these
certificates whenever any traffic is attempted between these nodes. We
call this Opportunistic IPsec.

There are two machines available to you for this specific lab
exercise. But as this configuration method's main feature is scalability,
you can pick up another X.509 certificate and repeat the process for
any other provided lab VM. However do be careful.  If you misconfigure
IPsec and do not allow fallback to cleartext, you can lock yourself
out of a VM.

=== Setup one IPsec machine to generate X.509 certificates:
. We will need to generate the required X.509 certificates.
It does not matter which of the machines you use to generate the required X.509 certificates. Make sure you are running Red Hat Enterprise Linux 7.5 or later. The only additional requirements are some software packages required for the supplied python script vpn-cert-gen.py. Copy this script on the *8IPSec* host and install the additional packages:

 # Install dependencies for vpn-cert-gen.py
 $ sudo yum install python2-pyOpenSSL
 # Generate the certificates
 $ mkdir labcerts
 $ cd labcerts
 $ /root/vpn-cert-gen.py --wipe

creating CA cert
 OK: CA system completely re-initialized
 # ls
cacerts  certs  keys  mobileconfig  pkcs12  serial.txt

You should now see a few new directories. The cacerts/ directory contains the Certificate Agency (CA) certificate. The certs/ directory contains the regular node certificates and the keys/ directory contains the private keys. But the script has already combined these for you into PKCS#12 based certificates in the pkcs12/ directory. The mobileconfig/ directory has Apple device profiles that include the PKCS#12 certificate and all other configuration items that are needed for those devices, but these files are only useful when building a Remote Access VPN server. We will not use them for this mesh host-to-host encryption using Opportunistic IPsec.

Just pick the proper pkcs12/*.p12 files for each of the hosts you want to add to the crypto mesh. From here onwards, all operations are performed as root.

Note that due to one security issue, the certificates must have a SubjectAltName specifying the IP address they are using (to prevent one machine from impersonating another). Since we do not have full reverse DNS and DNSSEC in this lab, the python script hardcodes the IP of the SubjectAltName. If you want to add one of your other machines to the mesh, edit the python script and add the name for that machines with the IP SubjectAltName just like it is hardcoded now for ipsec.example.com and ipsec2.example.com.

=== Setup the machine for Opportunistic IPsec:

. As *root* on *9IPSec*, install libreswan:

 # yum install libreswan
 # ipsec initnss

Libreswan uses the nss cryptographic library. It keeps all its X.509 certificates
and keys in its own NSS database in /etc/ipsec.d. If for some reason you want
libreswan to start a new NSS database from scratch, run the following commands:

 # systemctl stop ipsec
 # rm /etc/ipsec.d/*.db
 # ipsec initnss
 Initializing NSS database

. Once you have a fresh new NSS database, you can import the PKCS#12 certificate. For
example if you are installing ipsec.example.com.p12 on this host:
the host and run:

 # ipsec import /root/labcerts/pkcs12/ipsec.example.com.p12
 Enter password for PKCS12 file:
 pk12util: PKCS12 IMPORT SUCCESSFUL
 correcting trust bits for Certificate Agency (CA) - Test Org

. When prompted for the import password, use "secret".

. You can confirm the node's certificate and CA certificate are installed and available
to libreswan:

 # certutil -L -d sql:/etc/ipsec.d
 .
 Certificate Nickname                                         Trust Attributes
 .                                                            SSL,S/MIME,JAR/XPI
 .
 ipsec.example.com                                            u,u,u
 Certificate Agency (CA) - Test Org                           CT,,

. Create a new IPsec configuration file (eg /etc/ipsec.d/oe.example.com.conf) with the following content and
be sure to change the leftcert= value to match your actual certificate name as visible in NSS:

 # Example copy of this file available on ipsec.example.com in /root/oe-cert.conf
 conn private-or-clear
        # Prefer IPsec, allow cleartext
        rightrsasigkey=%cert
        right=%opportunisticgroup
        rightca=%same
        rightid=%fromcert
        left=%defaultroute
        leftcert=ipsec.example.com
        leftrsasigkey=%cert
        leftid=%fromcert
        type=tunnel
        ikev2=insist
        # tune remaining options to taste - fail fast to prevent packet loss to the app
        negotiationshunt=drop
        failureshunt=passthrough
        keyingtries=1
        retransmit-timeout=3s
        auto=ondemand
        authby=rsasig

 conn private
        # IPsec mandatory
        rightrsasigkey=%cert
        right=%opportunisticgroup
        rightca=%same
        rightid=%fromcert
        left=%defaultroute
        leftcert=ipsec.example.com
        leftrsasigkey=%cert
        leftid=%fromcert
        type=tunnel
        ikev2=insist
        # tune remaining options to taste - fail fast to prevent packet loss to the app
        negotiationshunt=hold
        failureshunt=drop
        # 0 means infinite tries
        keyingtries=0
        retransmit-timeout=3s
        auto=ondemand
        authby=rsasig

 conn clear-or-private
        # Prefer cleartext, allow cleartext
        rightrsasigkey=%cert
        right=%opportunisticgroup
        rightca=%same
        rightid=%fromcert
        left=%defaultroute
        leftcert=ipsec.example.com
        leftrsasigkey=%cert
        leftid=%fromcert
        type=tunnel
        ikev2=insist
        # tune remaining options to taste - fail fast to prevent packet loss to the app
        negotiationshunt=drop
        failureshunt=passthrough
        keyingtries=1
        retransmit-timeout=3s
        auto=add
        authby=rsasig

 conn clear
        type=passthrough
        authby=never
        left=%defaultroute
        right=%group
        auto=ondemand

. Make sure that the word "conn" starts at the beginning of the line. You will also find a copy of this file on the ipsec.example.com machines in /root/

. If you are running with SElinux enabled, ensure all the files are
properly labeled:

 # restorecon -Rv /etc/ipsec.*

These connections are the different groups that can we can assign to
network IP ranges. The conn "private" means that IPsec is mandatory and
all plaintext will be dropped. The conn "private-or-clear" means that
IPsec is attempted, but it will fallback to cleartext if it fails. The
conn "clear-or-private" means it will not initiate IPsec but it will
respond to a request for IPsec. The conn "clear" will never allow or
initiate IPsec.

To add an IP address (eg 192.168.0.66) or network range (eg
192.168.0.0/24) into one of these groups, simple add one line with the
IP address or network (in CIDR notation) into one of the files matching
the connection name in /etc/ipsec.d/policies For example:

 # echo "192.168.0.0/24" >> /etc/ipsec.d/policies/private-or-clear

. To ensure you will always be able to login via the workstation, add a
more specific entry into the "clear" group so the workstation is
excluded from all IPsec:

 # echo "192.168.0.3/32" >> /etc/ipsec.d/policies/clear

. These group names are built-in, so you cannot change them. Whenever you change one of these group files, the ipsec service needs to be restarted:

 # systemctl restart ipsec

. Repeat the commands you used to install and configure libreswan on ipsec.exameple.com (*8IPSec*) on the other machines, ipsec2.example.com (*9IPSec*).

. Then you can copy the configuration file and certificate PKCS#12 file from the first host to the second host. On ipsec.example.com type:

 # scp /root/labcerts/pkcs12/ipsec2.example.com.p12 root@ipsec2.example.com:/root
 # scp /etc/ipsec.d/oe.example.com.conf root@ipsec2.example.com:/etc/ipsec.d/

And on ipsec2.example.com continue:

 # ipsec import /root/ipsec2.example.com.p12
 # rm /root/ipsec2.example.com.p12
 # restorecon -Rv /etc/ipsec.d
 

. Don't forget the change the leftcert= entry in the configuration file on ipsec2.example.com to use its own to ipsec2.example.com. Also don't forget to issue the two "echo" commands above on ipsec2.example.com as well.

. Now you have configured the first two nodes. For each additional node, all you need to do is generate and install a new certificate, add the same configuration file with updated leftcert= entry and update the policy groups in /etc/ipsec.d/policies/ to match the first two nodes of the cluster. So for each added node, you do not need to reconfigure any of the previous nodes, as those are already configured to trust the same CA and talk IPsec to the same IP ranges as the new nodes.

. Now we are ready for testing our configuration. Start the IPsec subsystem on both configured nodes:

 # systemctl start ipsec

. Once you have done this on both machines, a simple ping from ipsec.example.com to ipsec2.example.com (or visa versa) should trigger an IPsec tunnel. The first ping might or might not fail depending on the time it takes to setup the IPsec connection. On ipsec.example.com type:

 # ping -c3 ipsec2.example.com

. You can check the system logs in /var/log/secure, or you can use one of the various status commands available:

 # ipsec whack --trafficstatus
 006 #2: "private-or-clear#192.168.0.0/24"[1] ...192.168.0.22, type=ESP, add_time=1523268130, inBytes=1848, outBytes=1848, id='C=CA, ST=Ontario, L=Toronto, O=Test Org, OU=Clients, CN=ipsec.example.com, E=pwouters@redhat.com'

. You can see the non-zero byte counters for IPsec packets that shows the kernel IPsec subsystem has encrypted and decrypted the network packets. A more verbose command is:

 # ipsec status
 [ lots of output ]

. If you think something went wrong and the ipsec status command does not show you the connections private, private-or-clear and clear-or-private (and their instances)
then issue a manual command to see why loading failed:

 # ipsec auto --add private

. If there is some kind of failure (eg the group is "private" but the
remote end is not functional), there will be no IPsec tunnel visible,
but you should be able to see the "shunts" that prevent or allow
unencrypted traffic on the network.

 # ipsec whack --shuntstatus
 000 Bare Shunt list:
 000
 000 192.168.0.23/32:0 -0-> 192.168.0.22/32:0 => %drop 0    oe-failing

. There are a few different types of shunt. The negotiationshunt determines what to do with packets while the IPsec connection is being established. Usually people want to hold the packets to prevents leaks, but if encryption is only "nice to have" and an uninterrupted service is more important, you can set this option to "passthrough". The failureshunt option determines what to do when negotiation fails. For the "private-or-clear" entry in your configuration file, you can see it is set to "passthrough", allowing unencrypted traffic. For the "private" entry you can see it is set to "drop" to disallow unencrypted traffic.

. You can use tcpdump to confirm that the connection is encrypted. Run a ping on one host, and run tcpdump on the other host:

 # tcpdump -i eth0 -n esp
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
05:58:18.003410 IP 192.168.0.22 > 192.168.0.23: ESP(spi=0x84019944,seq=0x6), length 120
05:58:18.003684 IP 192.168.0.23 > 192.168.0.22: ESP(spi=0x5b312cc5,seq=0x6), length 120
05:58:19.004840 IP 192.168.0.22 > 192.168.0.23: ESP(spi=0x84019944,seq=0x7), length 120
05:58:19.005096 IP 192.168.0.23 > 192.168.0.22: ESP(spi=0x5b312cc5,seq=0x7), length 120
05:58:20.006529 IP 192.168.0.22 > 192.168.0.23: ESP(spi=0x84019944,seq=0x8), length 120
05:58:20.006730 IP 192.168.0.23 > 192.168.0.22: ESP(spi=0x5b312cc5,seq=0x8), length 120

. Note due to how the kernel hooks for IPsec and tcpdump interacts, if you look at all traffic over an interface, you might see unencrypted packets going out and encrypted (proto ESP) and decrypted packets coming in. This happens because packets are encrypted by IPsec after the tcpdump hook has seen the packet on some kernel version. The easiest indicator of whether traffic is encrypted is to use the above mentioned trafficstatus command.

. Simply repeat this process on any new node to create your crypto mesh. If you have added the entire network range (192.168.0.0/24) to the private or private-or-clear groups, then for every new node you add, you do not need to reconfigure anything on the existing node.

. You can also redo the test and not run libreswan on one node and do a ping. You should see a few packets stalled or failing (based on whether the IP or subnet appears in /etc/ipsec.d/policies/private or /etc/ipsec.d/policies/private-or-clear) before it fails to clear or installs a block.

. If you run into more problems or you want to see in great detail what is happening, you can enable two lines in /etc/ipsec.conf to get all logs in a file and with full debugging. It is important to use file logging with full debugging because otherwise the rsyslog or systemd ratelimit will kick in and you will miss messages.

 # example /etc/ipsec.conf
 config setup
	logfile=/var/log/pluto.log
	plutodebug=all

 include /etc/ipsec.d/*.conf


. If everything works as expected, you would now be ready to enable the IPsec services on your cluster on every startup. So on each node run:

 # systemctl enable ipsec
 # systemctl start ipsec

. For more information on Opportunistc IPsec, please see https://libreswan.org/wiki/Main_Page


 <<top>>

 link:README.adoc#table-of-contents[ Table of Contents ] | link:lab5_USBGuard.adoc[ Lab 5: USBGuard ]
