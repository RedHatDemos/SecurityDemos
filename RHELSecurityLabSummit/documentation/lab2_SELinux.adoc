
= Security Enhanced Linux

Security Enhanced Linux is a representative of Proactive Security. In case of SELinux it means that a system is protected from consequences of exploits in window of vulnerability until a security fix is released. This protection is done by defined SELinux policy on your system.

The lab is split to three parts. In the first part, you will become a hacker and you will try to proceed a real vulnerability on given Red Hat Enterprise Linux 7 system and explore how SELinux helps to protect this system. In the second part, you will turn SELinux on for an environment containing a setup of web servers. In the last part, you will configure SELinux according to a STIG rule.

== SELinux policy
SELinux *isolates* all processes running on the system to *mitigate* attacks which take advantage of privilege escalation. Privilege escalation means that a process gains more access rights than it should have. To prevent this, SELinux enforces Mandatory Access Control (MAC) mechanism over all processes. It labels every process, file, or directory according to rules specified in a security policy known as the SELinux policy. The SELinux policy also specifies how processes interact with each other and how they can access files and directories. SELinux denies every action that it is not explicitly allowed by the SELinux policy.

Do we have any real example where this mentioned process isolation helped from a privilege escalation of an exploit? 

Yes, we have.

Let's become a hacker and try to exploit Red Hat Enterprise Linux 7 with Shellshock vulnerability.

== Exploiting Red Hat Enterprise Linux 7 with Shellshock vulnerability

<Describe shellshock vulnerability, root issue in exploit was allowing
put command after env variable in command, we'll use this vuln and try
to gain access to selinux4 system>

What does SELinux do to contain the the bash exploit (ShellShock)?

<put two pictures which will tell that SELiux does not prevent from exploit but take advantage of privilege escalation>

=== Lab User Story
<As an enterprise admin I want to have SELinux in enforcing mode to
mitigate damage by 0day vulnerabilities>

=== Implementation

The lab exercise is split into three steps:

. Exploiting RHEL system with SELinux in Permissive mode
. Exploiting RHEL system with SELinux in Enforcing mode
. Analyzing SELinux denials

=== Configuration

Exploit will be executed from _selinux1_ system, therefore use ssh to connect _selinux1_ system.

    # ssh root@selinux1

Move to directory /root/selinux_sctipts/ where are all the scripts needed for provide attack.

    # cd /root/selinux_scripts

It's needed to have two terminals opened, one for listening on 9999 tcp port, second one for executing exploit script. Please, open two terminals connect to selinux1 system and change directory to /root/selinux_scripts.

Following image describing flow how exploit will be provided. One left side there is victim server (selinux4 system) and from attacker machine will be http request send and part of this httpd request will be revert shell to attacker machine listening on tcp port 9999

image:images/lab2-shellshock-flow.png[]

=== Exploiting system with SELinux in Permissive mode

_selinux4_ system has SELinux in permissive mode by default, there is running Apache service running with old version of bash. Everything is ready to run the exploit.

Based on flow of the ShellShock! attack, it's necessary to start listening on tcp port 9999 on selinux1 system.

    # nc -lvp 9999
    Ncat: Version 7.50 ( https://nmap.org/ncat )
    Ncat: Listening on :::9999
    Ncat: Listening on 0.0.0.0:9999

Ncat is a feature-packed networking utility which reads and writes data across networks from the command line.

Now, from another terminal, let's run the exploit

    # ./shellshock_exploit.sh

Right now, on terminal where nc command was executed, bash promnt should appeared.

    # nc -lvp 9999
    Ncat: Version 7.50 ( https://nmap.org/ncat )
    Ncat: Listening on :::9999
    Ncat: Listening on 0.0.0.0:9999
    Ncat: Connection from 192.168.0.24.
    Ncat: Connection from 192.168.0.24:38668.
    bash: no job control in this shell
    bash-4.2$

For testing purpose, few commands could be executed on victim (_selinux4_ machine)

    bash-4.2$ id
    id
    uid=48(apache) gid=48(apache) groups=48(apache) context=system_u:system_r:httpd_sys_script_t:s0
    bash-4.2$ uname -a
    uname -a
    Linux selinux4.example.com 3.10.0-418.el7.x86_64 #1 SMP Thu May 26 20:35:02 EDT 2016 x86_64 x86_64 x86_64 GNU/Linux

    # exit

==== Set SELinux to enforcing mode

Victim server (_selinux4_ system) has SELinux in permissive mode. Now, let's switch SELinux to enforcing and repeat the attack.

Connect to _selinux4_ and switch to Enforcing mode

    # ssh root@selinux4
    # setenforce 1
    # exit

=== Exploiting system with SELinux in Enforcing mode

Right now, attack will be repeated but SELinux is in Enforcing mode on victim server (_selinux4_ system)

Based on flow of the _ShellShock!_ attack, it's necessary to start listening on tcp port 9999 on _selinux1_ system.

    # nc -lvp 9999
    Ncat: Version 7.50 ( https://nmap.org/ncat )
    Ncat: Listening on :::9999
    Ncat: Listening on 0.0.0.0:9999

_Ncat_ is a feature-packed networking utility which reads and writes data across networks from the command line.

Now, from another terminal, let's run the exploit

    # ./shellshock_exploit.sh

As you can see, there is no bash prompt on terminal where you used _nc_ command, because SELinux blocked this access. SELinux did his job!

==== Analyzing SELinux denial

Let's analyze what happened and why SELinux blocked ShellShock! exploit.

Connect to selinux4 system from selinux1 machine

    # ssh root@selinux4
    # ausearch -m AVC -ts today | grep name_connect
    type=AVC msg=audit(1524909646.681:86): avc:  denied  { name_connect } for  pid=2091 comm="bashbug.sh" dest=9999 scontext=system_u:system_r:httpd_sys_script_t:s0 tcontext=system_u:object_r:jboss_management_port_t:s0 tclass=tcp_socket

This is avc record from Audit daemon, which saying that cgi script called bashbug.sh labeled as httpd_sys_script_t tried to connect to tcp port 9999 labeled as jboss_management_port_t, fortunately there is no allow rules for this access, so it was denied by kernel and SELinux mitigate this attack.

= Enabling SELinux via Ansible

=== Lab User Story

As an enterprise administrator I want to enable SELinux in my environment with an Apache server using both custom and standard paths for web files so that my Apache server is fully confined by SELinux. I want to use linux-system-roles/selinux as an ansible role which configures SELinux.

=== Lab Detailed User Story

As an enterprise administrator I have an environment with Apache webservers where both default and custom paths for Apache web files are used.

 * /var/www/html (default)
 * /var/www_new/html (custom)

These web files are accessible using tcp/80 and tcp/7070 ports on each web server.

 * selinux2.example.com:80 (default)
 * selinux2.example.com:7070 (custom)

SELinux is disabled for all web servers by default. I want to turn SELinux on for all web servers without breaking any functionality and use linux-system-roles/selinux ansible role for it.

=== Implementation

The SELinux part of the lab environment consists from three machines (needs to be started in lab environment)

 * selinux1, selinux1.example.com (RHEL-7 admin host)
 * selinux2, selinux2.example.com (RHEL-7 host)
 * selinux3, selinux3.example.com (RHEL-6 host)

The first _selinux1.example.com_ host will be used as an admin interface to setup another two hosts where all configuration steps will be proceeded. The whole entire _Enabling SELinux via Ansible_ lab exercise is divided to four steps.

. Configuration
. Demonstration
. Summary
. Revert script

== Configuration

*Important*: All steps in the _Configuration_ section have been already performed in the Summit lab environment. They are mentioned from an informative purpose and they need to executed (except the package installation) only if you use the revert script for this lab

=== Basic environment configuration

    # ssh root@selinux1

. Update DNS records on the _selinux1_ server.

	# cat /etc/hosts
	127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
	::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

	192.168.0.20 selinux2
	192.168.0.21 selinux3

. Install the __ansible__ package on the _selinux1_ host.

	# yum install ansible -y

. Enter the _selinux_scripts_ working directory on the _selinux1_ host.

	# cd /root/selinux_scripts

. Create an inventory file for our Ansible usage.

	# cat inventory
	selinux2
	selinux3

=== Configuration of Apache webservers and with disabled SELinux.

In this section, _apache_ webservers will be setup via the _setup_webserver.yml_ playbook on _selinux2_ and _selinux3_ hosts  and SELinux will be turned off to create an environment described in the detailed lab user story.

Test whether all servers are available via the _ansible_ command.

	# ansible all -i inventory -m ping -u root

Ansible script will pass all listed servers in the _inventory_ file and will send test if they are accessible. All servers should return a pong response.

	selinux2.example.com | SUCCESS => {
        	"changed": false,
	        "ping": "pong"
	}

    selinux3.example.com | SUCCESS => {
        "changed": false,
	        "ping": "pong"
	}

Configure Apache web servers on given servers via the _setup_webserver.yml_ playbook.

	# ansible-playbook -i inventory -u root setup-webserver.yml

The following actions are performed for all hosts mentioned in the _inventory_ file:

 * SELinux is disabled.
 * Apache webservers are
  ** installed
  ** configured to listen on _tcp/80_ and _tcp/7070_ ports via the _linux-sytem-roles/firewall_ ansible role.
  ** configured to use two root directories for web files,

	/var/www/html (default)
	/var/www_new/html (custom)

  ** are rebooted,

At the end we need to install the _setools-console_ package containing SELinux policy quiery tools which will be used for SELinux Troubleshooting.

	# ssh root@selinux2
	# yum install setools-console
    # exit

	# ssh root@selinux3
	# yum install setools-console
    # exit

== Demonstration

=== Test configured setup

    # hostname
    selinux1.example.com

    # cd /root/selinux_scripts

	# curl selinux2
	<h1>Default Document Root</h1>

	# curl selinux2:7070
	<h1>Custom Document Root</h1>

	# curl selinux3
	<h1>Default Document Root</h1>

	# curl selinux3:7070
	<h1>Custom Document Root</h1>

    # ssh root@selinux2
    # getenforce
    Disabled

    # ssh root@selinux3
    # getenforce
    Disabled

=== Turning SELinux on

Setup SELinux to _permissive_ mode and relabel whole filesystem.

	# ansible-playbook -i inventory -u root enable-selinux.yml


SELinux is switched to _permissive_ mode using the _enable-selinux_ playbook. It means that SELinux policy is enabled but is not enforced. We can use the _getenforce_ and _sestatus_ utility to view the current SELinux mode for our server(s).

    # ssh root@selinux2
    # getenforce
    # sestatus
    # exit

SELinux does not deny access, but denials are logged for actions that would have been denied if running in enforcing mode. In order to show logged denials for certain actions we need to run the _curl_ command. AVC denial(s) will be generated and we can view it via the _ausearch_ command [3].

	# curl selinux2
	# curl selinux3

	# ssh root@selinux2
    # ausearch -m AVC -su httpd_t -ts recent

	avc:  denied  { name_bind } for  pid=1830 comm="httpd" src=7070 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:unreserved_port_t:s0 tclass=tcp_socket

	avc:  denied  { read } for  pid=1831 comm="httpd" name="index.html" dev="vda3" ino=8511801 scontext=system_u:system_r:httpd_t:s0 tcontext=system_u:object_r:var_t:s0 tclass=file

    # exit

=== SELinux Troubleshooting

SELinux Troubleshooting can be performed on both hosts. We will use the _selinux2_ host for the following examples.

Log into the _selinux2_ host.

	# ssh root@selinux2

==== SELinux Port

SELinux _httpd_t_ process domain used for Apache webservers is not able to bind to _tcp/7070_ port by default. There is no default rule for this access in the SELinux policy on the RHEL-7 _selinux2_ host.

	# sesearch -A -s httpd_t -t unreserved_port_t -c tcp_socket -p name_bind -C

Note: Use _port_ instead of _unreserved_port_t_ for this query on the _selinux3_ host.

    # sesearch -A -s httpd_t -t port_t -c tcp_socket -p name_bind -C

Compare to that Apache webservers can bind other ports and these SELinux port types can be assigned to our selected custom port (_tcp/7070_).

	# sesearch -A -s httpd_t -c tcp_socket -p name_bind

==== SELinux File context

SELinux _httpd_t_ process domain used for Apache webservers is not able to read a general _/var_ content with SELinux _var_t_ file type. There is no rule for this access in the SELinux policy.

	# sesearch -A -s httpd_t -t var_t -c file -p read

Compare to that Apache webservers can read a specific content with a specific SELinux file type.

	# sesearch -A -s httpd_t -c file -p read

We can use the matchpathcon utility to decide what should be a proper context for our alternative location for web files.

    # matchpathcon /var/www/html
	/var/www/html    system_u:object_r:httpd_sys_content_t:s0

    # exit

=== SELinux _setup-selinux.yml_ ansible playbook

According to our SELinux Troubleshooting we will create  an SELinux ansible playbook which will switch SELinux to Permissive mode and will apply all needed changes for our webservers's configuration.

The playbook uses linux-system-roles/selinux ansible role.

    # hostname
    selinux1.example.com

    # pwd
    /root/selinux_scripts

	# cat setup-selinux.yml

        ---
	- hosts: all
	    become: true
        become_user: root
        vars:

        roles:
            - linux-system-roles.selinux

==== Configure SELinux variables

Note: All code lines are append into the _vars_ section in the _setup_selinux.yml_ ansible playbook.

Switch SELinux to Enforcing mode.

    SELinux_type: targeted
    SELinux_mode: enforcing
    SELinux_change_running: 1

Webservers use the custom _/var/www_new/html_ path for web pages. SELinux labels have to be fixed for this directory and sub directories/files to reflect the default SELinux security labels for the _/var/www/html_ location. It is ensured by the following lines in the playbook:

    SELinux_file_contexts:
        - { target: '/var/www_new(/.*)?', setype: 'httpd_sys_content_t', ftype: 'a' }

Once SELinux security labels are defined in the SELinux context database, these labels should be applied into extended attributes of selected files.  It is ensured by the following lines in the playbook:

    SELinux_restore_dirs:
        - /var/www_new

All web servers are binded to the custom _tcp/7070_ port in our configuration. This setup needs to be reflected in a SELinux configuration. It is ensured by the following lines in the playbook:

    SELinux_ports:
        - { ports: '7070', proto: 'tcp', setype: 'http_port_t', state: 'present' }

==== Final SELinux _setup-selinux.yml_ ansible playbook

    ---
    - hosts: all
    become: true
    become_user: root
    vars:
        SELinux_type: targeted
        SELinux_mode: enforcing
        SELinux_change_running: 1
        SELinux_file_contexts:
            - { target: '/var/www_new(/.*)?', setype: 'httpd_sys_content_t', ftype: 'a' }
        SELinux_restore_dirs:
            - /var/www_new/
        SELinux_ports:
            - { ports: '7070', proto: 'tcp', setype: 'http_port_t', state: 'present' }

    roles:
        - linux-system-roles.selinux

Apply defined configurations for all servers.

    # ansible-playbook -i inventory -u root setup-selinux.yml

=== Re-test configured setup

List all SELinux configuration changes.

    # ssh selinux2
    # semanage export
    # exit


    # ssh selinux3
    # semanage -o -
    # exit

Check the current SELinux status for all servers..

    # ansible all -i inventory -u root -a getenforce

Check the functionality with enabled SELinux.

    # curl selinux2
    # curl selinux2:7070

    # curl selinux3
    # curl selinux3:7070

== Summary

SELinux brings additional security for your environment and very often needs to be additionally modify to reflect the current environment configuration. For these cases, SELinux can be switched to Permissive mode as a debugging mode to not block a basic functionality of systems. With this mode we can run for a time period to debug all possible SELinux AVC denials and it makes turning SELinux on easier. There are many ways how to view or modify the installed SELinux policy. In this lab, we used SELinux Ansible role to distribute all needed changes in the SELinux policy to make our Apache configuration working with SELinux in Enforcing mode.

== Revert script

There is a revert script for the lab environment configuration. This script can be used to start from the scratch with this laband all actions in the _Configuration_ section need to be executed except the package installation.

    # hostname
    selinux1.example.com

    # pwd
    /root/selinux_scripts

    # cat inventory
    selinux2
    selinux3

    # ansible-playbook -i inventory -u root revert-all.yml

= How to set up a system with SELinux confined users

== Introduction

In Red Hat Enterprise Linux, Linux users are mapped to the SELinux _unconfined_u_ user by default. All processes run by _unconfined_u_ are in the _unconfined_t_ domain. This means that users can access across the system within the limits of the standard Linux DAC policy. However, a number of confined SELinux users are available in Red Hat Enterprise Linux. This means that users can be restricted to limited set of capabilities. Each Linux user is mapped to an SELinux user using SELinux policy, allowing Linux users to inherit the restrictions placed on SELinux users.

== Lab User Story

As an enterprise administrator I want my systems to follow the STIG rule V-71971 so that my system will be fully confined without unconfined users.
I want one administrator user who can become root and manage the system, and other users to be limited so that they can't become root.

== Implementation

The lab exercise is split into three steps:

. Confine regular Linux users
. Confine Linux root users
. Revert script

== Configuration

Make sure that the "revert script" from previous workshop was executed, even if you didn't do the workshop.

    # ansible-playbook -i inventory -u root revert-all.yml

== Confine regular Linux users

All actions are performed on the _selinux2_ host which is a RHEL-7.6 Beta installation.

Log into the _selinux1_ host system and then to _selinux2_ system:

    # ssh root@selinux1
    [root@selinux1 ~]# ssh root@selinux2

Linux users can be assigned to SELinux users using semanage login tool. By default users are mapped to _unconfined_u_:

    # semanage login -l

=== Change the default mapping

In order to change mapping all Linux users we need to modify the record with __default__ which represents all users without explicit mapping.

_system_u_ is a special user used only for system processes and in the future will not be listed.

    # semanage login -m -s user_u -r s0 __default__
    # semanage login -l

=== Add a test user

After this when users (not root) will log in, their processes will run _user_t_ domain. Every user session but root will run with _user_t_:


    # adduser user42
    # passwd user42
    â€¦

    # ssh user42@localhost
    user42@localhost's password:

    [user42@selinux2 ~]$ id -Z
    user_u:user_r:user_t:s0

    [user42@selinux2 ~]$ ps axZ
    LABEL                     PID TTY    STAT  TIME COMMAND
    -                           1 ?      Ss    0:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 21
    user_u:user_r:user_t:s0  2780 ?      S     0:00 sshd: user42@pts/1
    user_u:user_r:user_t:s0  2781 pts/1  Ss    0:00 -bash
    user_u:user_r:user_t:s0  2808 pts/1  R+    0:00 ps axZ
    # exit

Now we can try if the user can become root. We need to add following line:

    # visudo -f /etc/sudoers.d/administrators
    # grep user42 /etc/sudoers.d/administrators
    user42  ALL=(ALL)       NOPASSWD: ALL

    # ssh user42@localhost
    user42@localhost's password:

    [user42@selinux2 ~]$ sudo -i
    sudo: PERM_SUDOERS: setresuid(-1, 1, -1): Operation not permitted
    sudo: no valid sudoers sources found, quitting
    sudo: setresuid() [0, 0, 0] -> [1001, -1, -1]: Operation not permitted
    sudo: unable to initialize policy plugin

And the same attempt in permissive mode.

    [user42@selinux2 ~]$ exit
    # id -Z
    unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
    # setenforce 0
    # ssh user42@localhost
    user42@localhost's password:

    [user42@selinux2 ~]$ sudo -i
    # id
    uid=0(root) gid=0(root) groups=0(root) context=user_u:user_r:user_t:s0
    [root@selinux2 ~]# id -Z
    User_u:user_r:user_t:s0
    [root@selinux2 ~]# exit
    [user42@selinux2 ~]$ exit
    [root@selinux2 ~]# setenforce 1

Since in permissive mode SELinux denials are not enforced, _user42_ can become root but we can see that the context stayed _user_t_ and didn't change to _unconfined_t_.

== Confined Administrator

There are two basic methods how to confine administator user.
Administrator can be directly mapped to _sysadm_u_ SELinux user so that when such user logs in, the session will be run with _sysadm_t_ domain. In this case you need to enable _ssh_sysadm_login_ SELinux boolean in order to allow users assigned _sysadm_u_ to login using ssh.

    # semanage user -m -R "sysadm_r secadm_r" sysadm_u
    # adduser -G wheel -Z sysadm_u admin1
    # passwd admin1

    # semanage login -l | grep admin
    admin1               sysadm_u             s0-s0:c0.c1023       *

    # setsebool -P ssh_sysadm_login on
    # ssh admin1@localhost

    [admin1@selinux2 ~]$ id -Z
    sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023

    $ sudo -i
    [sudo] password for admin1:


    [root@selinux2 ~]# id -Z
    sysadm_u:sysadm_r:sysadm_t:s0-s0:c0.c1023

Now we can try to perform admin's operation which can be executed only by admin SELinux users.

    [root@selinux2 ~]# systemctl restart sshd
    [root@selinux2 ~]# exit
    [admin1@selinux2 ~]# exit

The other way is to assign u administer users to _staff_u_ and configure _sudo_ so that particular users can gain SELinux administrator role.

    # adduser -G wheel -Z staff_u admin2
    # passwd admin2
    # semanage login -l | grep admin
    admin1               sysadm_u             s0-s0:c0.c1023       *
    admin2               staff_u              s0-s0:c0.c1023       *


    # ssh admin2@localhost
    [admin2@selinux2 ~]$ id -Z
    staff_u:staff_r:staff_t:s0-s0:c0.c1023

    [admin2@selinux2 ~]$ sudo -i
    [sudo] password for admin2:
    -bash: /root/.bash_profile: Permission denied
    -bash-4.2# id -Z
    staff_u:staff_r:staff_t:s0-s0:c0.c1023


Now we can again try to perform administrator's operation which can be executed only by administrator SELinux users.

    -bash-4.2# systemctl restart sshd
    Failed to restart sshd.service: Access denied
    See system logs and 'systemctl status sshd.service' for details.
    -bash-4.2# exit
    [admin2@selinux2 ~]$ exit

To allow admin2 user to gain SELinux administrator role you need to add the following rule to sudoers.

    # visudo -f /etc/sudoers.d/administrators

Append following line to end of file:

    admin2  ALL=(ALL)  TYPE=sysadm_t ROLE=sysadm_r    ALL
    admin2  ALL=(ALL)  TYPE=secadm_t ROLE=secadm_r /usr/sbin/semanage,/usr/sbin/semodule

Admin2 can gain administrator role using sudo now.

    # ssh admin2@localhost
    [admin2@selinux2 ~]$ sudo -i
    [sudo] password for admin2:

    [root@selinux2 ~]# id -Z
    staff_u:sysadm_r:sysadm_t:s0-s0:c0.c1023

    [root@selinux2 ~]# systemctl restart sshd
    [root@selinux2 ~]#

    [root@selinux2 ~]# exit
    [admin2@selinux2 ~]# exit

== Revert script

There is a revert script to restore the default SELinux Users configuration. This script needs to be performed on the _selinux2_ host.

    # hostname
    selinux2.example.com

    # cd /root
    # sh confined_users_revert.sh

<<top>>
link:README.adoc#table-of-contents[ Table of Contents ] | link:lab3_NBDE.adoc[Lab 3: NBDE]
